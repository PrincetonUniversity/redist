---
title: "Tidy `redist`"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tidy `redist`}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Setup

We begin by loading `tidyverse` and the `redist` library, and reading in our 
shapefile.
```{r message=F}
library(tidyverse)
library(redist)

data(east_tx)
print(texas_shp)
```

# Specifying the Redistricting Problem

The first thing we do is to create a `redist_map` object, which is essentially
a data frame along with an adjacency graph and a little extra metadata about
the redistricting problem at hand.  It's important to create this object early
on, since data operations like filtering and summarizing will affect the graph
structure, number of district, and population constraints.

Here, the existing district assignment is stored in the `cd` column. We provide
let `redist_map` know about this by providing the `existing_col` argument, and
we use `max(cd)` to count the total number of districts.
```{r}
tx = redist_map(texas_shp, pop_tol=0.05, existing_col=cd)
print(tx)
```
Our original shapefile stored its geographic information in terms of latitude
and longitude. While common, this can cause problems for some of the geographic
operations used in the analysis process, so by default `redist_map` will
reproject the shapefile geometry to a new coordinate system.  Whether to do this
and which coordinate system to use can be controlled using the `planarize`
argument.

## Subsetting
Suppose that we want to focus our analysis on the Houston area, which for our
purposes means the 2nd, 7th, 9th, 18th, 22nd, and 29th congressional districts.
We can do this simply by using `dplyr`'s `filter()` function.
```{r}
houston_area = filter(tx, cd %in% c(2, 7, 9, 18, 22, 29)) 
print(houston_area)
```
Behind the scenes, `redist` has adjusted the adjacency graph to remove the 
precincts that were filtered away. It has also adjusted the number of districts
and the population bounds.

We can easily plot this new map, either by congressional district or by any
other quantity of interest.
```{r}
plot(houston_area, edges=F, centroids=F) # hide the hundreds of graph edges and vertices
plot(houston_area, hisp/pop)
```

## Merging
If we want to base our analysis on a geographical unit other than precincts,
we use the `merge_by()` function, which calls `dplyr`'s `group_by()` and
`summarize()` in the background.  It also tries to intelligently summarize the
other columns in the data frame---adding up the population in each county,
for instance.  By default, `merge_by()` will also group by the current
congressional districts, if they are provided, to avoid erasing these lines.
```{r}
houston_counties = houston_area %>%
    merge_by(county, drop_geom=FALSE)
print(houston_counties)
plot(houston_counties, hisp/pop)
```

We specify `drop_geom=FALSE` so that the shapefile geometries are also merged.
Since this is a time-consuming process and is not necessary for redistricting
analysis, by default `merge_by()` drops the shapefile geometry. 

If more fine-grained control is needed than is provided by `merge_by()`, you
can always use `group_by()` and `summarize()`, which will still make the 
appropriate modifications to the adjacency graph.

Another common use of `merge_by()` is for creating district "cores": gluing
precincts in the "core" of an area together, to ensure that they stay together
throughout redistricting.  This has the effect of imposing a status quo
constraint when applied to existing districts. Here, any precincts that are
not within 1 precinct of the district borders will be merged into the district
cores.
```{r}
houston_cores = houston_area %>%
    mutate(cd_cores = make_cores(within=1)) %>% 
    merge_by(cd_cores, drop_geom=F)
print(houston_cores)
plot(houston_cores, centroids=F)
```

# Simulating and Analyzing Plans
After preprocessing the map to focus on the redistricting problem of interest,
we are ready to run the redistricting simulation.  The recommended simulation
function is `redist_smc`, which uses a Sequential Monte Carlo (SMC) 
algorithm.^[McCartan, C., & Imai, K. (2020). Sequential Monte Carlo for Sampling
Balanced and Compact Redistricting Plans. Available at
<https://imai.fas.harvard.edu/research/files/SMCredist.pdf>.]

```{r message=F}
houston_plans = redist_smc(houston_cores, 100, counties=county) %>%
    add_reference(houston_cores$cd)
print(houston_plans)
```

We can then easily add summary statistics for each district. The 
`distr_compactness` and `group_frac` functions will implicitly reference the
simulated plans matrix when called inside `mutate()`.
```{r}
houston_plans = houston_plans %>%
    mutate(comp = distr_compactness(houston_cores),
           pct_hisp = group_frac(houston_cores, hvap, vap),
           pct_black = group_frac(houston_cores, bvap, vap),
           pct_white = group_frac(houston_cores, wvap, vap),
           pct_min = 1 - pct_white)
print(houston_plans)
```

From there, it's easy to summary statistics by plan.
```{r}
min_distr = group_by(houston_plans, draw) %>%
    summarize(n_black = sum(pct_black >= 0.5),
              n_hisp = sum(pct_hisp >= 0.5),
              n_coalition = sum(pct_min >= 0.5))
print(min_distr)
```

And `redist` provides several useful plotting functions. By default, `plot`
calls `hist`, which makes a histogram of a quantity of interest along with
a reference line for each reference plan.
```{r}
# ggplots with nice defaults and labels
plot(min_distr, n_coalition)
plot(houston_plans, pct_hisp, type="distr_qtys")
```

We can also re-index the plans back to the original, un-merged map.
```{r}
houston_orig_plans = pullback(houston_plans)
print(houston_orig_plans)
plot(houston_orig_plans, type="plan", draw=5, geom=houston_area)
```

# All Together
A minimum working example for the 'signature of gerrymandering'.
```{r message=F}
houston = texas_shp %>%
    redist_map(pop_tol=0.05, existing_col=cd) %>%
    filter(cd %in% c(2, 7, 9, 18, 22, 29)) %>% # filter to Houston area
    mutate(cd_cores = make_cores(within=1)) %>%
    merge_by(cd_cores)

houston_plans = redist_smc(houston, 100, counties=county, silent=T) %>%    
    add_reference(houston$cd) %>%
    mutate(pct_hisp = group_frac(houston, hisp, pop))

plot(houston_plans, type="distr_qtys", pct_hisp)
```
